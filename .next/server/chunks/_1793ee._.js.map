{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/intake/normalize.ts"],"sourcesContent":["export function normalizeInput(text: string): string {\r\n  return text\r\n    .replace(/\\r\\n/g, \"\\n\")\r\n    .replace(/\\t/g, \" \")\r\n    .replace(/\\s{2,}/g, \" \")\r\n    .trim();\r\n}\r\n"],"names":[],"mappings":";;;AAAO,SAAS,eAAe,IAAY;IACzC,OAAO,KACJ,OAAO,CAAC,SAAS,MACjB,OAAO,CAAC,OAAO,KACf,OAAO,CAAC,WAAW,KACnB,IAAI;AACT"}},
    {"offset": {"line": 11, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/intake/tone-calibration.ts"],"sourcesContent":["export type Tone =\r\n  | \"neutral\"\r\n  | \"confident\"\r\n  | \"assertive\"\r\n  | \"speculative\";\r\n\r\nexport function calibrateTone(text: string): Tone {\r\n  const confidenceMarkers = [\"clearly\", \"definitely\", \"proven\"];\r\n  const speculativeMarkers = [\"might\", \"could\", \"possibly\"];\r\n\r\n  if (confidenceMarkers.some(w => text.includes(w))) return \"assertive\";\r\n  if (speculativeMarkers.some(w => text.includes(w))) return \"speculative\";\r\n\r\n  return \"neutral\";\r\n}\r\n"],"names":[],"mappings":";;;AAMO,SAAS,cAAc,IAAY;IACxC,MAAM,oBAAoB;QAAC;QAAW;QAAc;KAAS;IAC7D,MAAM,qBAAqB;QAAC;QAAS;QAAS;KAAW;IAEzD,IAAI,kBAAkB,IAAI,CAAC,CAAA,IAAK,KAAK,QAAQ,CAAC,KAAK,OAAO;IAC1D,IAAI,mBAAmB,IAAI,CAAC,CAAA,IAAK,KAAK,QAAQ,CAAC,KAAK,OAAO;IAE3D,OAAO;AACT"}},
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/intake/domain-classifier.ts"],"sourcesContent":["export type Domain =\r\n  | \"product\"\r\n  | \"finance\"\r\n  | \"legal\"\r\n  | \"research\"\r\n  | \"general\";\r\n\r\nexport function classifyDomain(text: string): Domain {\r\n  const t = text.toLowerCase();\r\n\r\n  if (t.includes(\"regulation\") || t.includes(\"law\")) return \"legal\";\r\n  if (t.includes(\"revenue\") || t.includes(\"market\")) return \"finance\";\r\n  if (t.includes(\"experiment\") || t.includes(\"study\")) return \"research\";\r\n  if (t.includes(\"user\") || t.includes(\"feature\")) return \"product\";\r\n\r\n  return \"general\";\r\n}\r\n"],"names":[],"mappings":";;;AAOO,SAAS,eAAe,IAAY;IACzC,MAAM,IAAI,KAAK,WAAW;IAE1B,IAAI,EAAE,QAAQ,CAAC,iBAAiB,EAAE,QAAQ,CAAC,QAAQ,OAAO;IAC1D,IAAI,EAAE,QAAQ,CAAC,cAAc,EAAE,QAAQ,CAAC,WAAW,OAAO;IAC1D,IAAI,EAAE,QAAQ,CAAC,iBAAiB,EAAE,QAAQ,CAAC,UAAU,OAAO;IAC5D,IAAI,EAAE,QAAQ,CAAC,WAAW,EAAE,QAAQ,CAAC,YAAY,OAAO;IAExD,OAAO;AACT"}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/claims/claim-decomposer.ts"],"sourcesContent":["// core/claims/claim-decomposer.ts\r\nimport { ClaimType } from \"./claim-types\";\r\nimport { LLMProvider } from \"../../lib/llm/provider-adapter\";\r\n\r\nexport type AuditGravity = \"critical\" | \"high\" | \"medium\" | \"low\";\r\n\r\nexport type Claim = {\r\n  id: string;\r\n  text: string;\r\n  index: number;\r\n  type: ClaimType;\r\n  gravity: AuditGravity;\r\n  confidence: number;\r\n};\r\n\r\nexport async function decomposeClaimsAdvanced(\r\n  content: string,\r\n  provider: LLMProvider\r\n): Promise<Claim[]> {\r\n  const prompt = `\r\n    Act as a Senior Forensic Auditor (ex-McKinsey/SEC). \r\n    Decompose the following text into distinct, atomic claims.\r\n    \r\n    Assign 'Audit Gravity':\r\n    - critical: Violations of physical laws (Entropy, Thermodynamics) or SEC/FDA regulations.\r\n    - high: Numerical assertions or causal guarantees (e.g. \"will lead to X\").\r\n    - medium/low: Standard descriptive assertions.\r\n\r\n    Return result ONLY as a JSON array: [{\"text\": string, \"type\": ClaimType, \"gravity\": AuditGravity}]\r\n    Text: \"${content}\"\r\n  `;\r\n\r\n  const response = await provider.generate({ prompt, temperature: 0 });\r\n  const rawClaims: any[] = JSON.parse(response.text.replace(/```json|```/g, \"\").trim());\r\n\r\n  return rawClaims.map((c, idx) => ({\r\n    ...c,\r\n    id: `C${idx + 1}`,\r\n    index: idx,\r\n    confidence: 1.0,\r\n  }));\r\n}"],"names":[],"mappings":"AAAA,kCAAkC;;;;AAe3B,eAAe,wBACpB,OAAe,EACf,QAAqB;IAErB,MAAM,SAAS,CAAC;;;;;;;;;;WAUP,EAAE,QAAQ;EACnB,CAAC;IAED,MAAM,WAAW,MAAM,SAAS,QAAQ,CAAC;QAAE;QAAQ,aAAa;IAAE;IAClE,MAAM,YAAmB,KAAK,KAAK,CAAC,SAAS,IAAI,CAAC,OAAO,CAAC,gBAAgB,IAAI,IAAI;IAElF,OAAO,UAAU,GAAG,CAAC,CAAC,GAAG,MAAQ,CAAC;YAChC,GAAG,CAAC;YACJ,IAAI,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC;YACjB,OAAO;YACP,YAAY;QACd,CAAC;AACH"}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/tools/google-search.ts"],"sourcesContent":["// lib/tools/google-search.ts\r\nexport interface SearchResult {\r\n  title: string;\r\n  link: string;\r\n  snippet: string;\r\n}\r\n\r\nexport async function performWebSearch(query: string): Promise<SearchResult[]> {\r\n  const apiKey = process.env.GOOGLE_SEARCH_API_KEY;\r\n  const cx = process.env.GOOGLE_SEARCH_ENGINE_ID;\r\n\r\n  if (!apiKey || !cx) {\r\n    console.warn(\"Search API credentials missing. Skipping live grounding.\");\r\n    return [];\r\n  }\r\n\r\n  const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${cx}&q=${encodeURIComponent(query)}`;\r\n\r\n  try {\r\n    const response = await fetch(url);\r\n    const data = await response.json();\r\n\r\n    return (data.items || []).map((item: any) => ({\r\n      title: item.title,\r\n      link: item.link,\r\n      snippet: item.snippet,\r\n    }));\r\n  } catch (error) {\r\n    console.error(\"Google Search API Failure:\", error);\r\n    return [];\r\n  }\r\n}"],"names":[],"mappings":"AAAA,6BAA6B;;;;AAOtB,eAAe,iBAAiB,KAAa;IAClD,MAAM,SAAS,QAAQ,GAAG,CAAC,qBAAqB;IAChD,MAAM,KAAK,QAAQ,GAAG,CAAC,uBAAuB;IAE9C,IAAI,CAAC,UAAU,CAAC,IAAI;QAClB,QAAQ,IAAI,CAAC;QACb,OAAO,EAAE;IACX;IAEA,MAAM,MAAM,CAAC,+CAA+C,EAAE,OAAO,IAAI,EAAE,GAAG,GAAG,EAAE,mBAAmB,OAAO,CAAC;IAE9G,IAAI;QACF,MAAM,WAAW,MAAM,MAAM;QAC7B,MAAM,OAAO,MAAM,SAAS,IAAI;QAEhC,OAAO,CAAC,KAAK,KAAK,IAAI,EAAE,EAAE,GAAG,CAAC,CAAC,OAAc,CAAC;gBAC5C,OAAO,KAAK,KAAK;gBACjB,MAAM,KAAK,IAAI;gBACf,SAAS,KAAK,OAAO;YACvB,CAAC;IACH,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO,EAAE;IACX;AACF"}},
    {"offset": {"line": 114, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/claims/claim-linker.ts"],"sourcesContent":["import { Claim } from \"./claim-decomposer\";\r\n\r\nexport interface ClaimLink {\r\n  from: string;\r\n  to: string;\r\n}\r\n\r\nexport function linkClaims(claims: Claim[]): ClaimLink[] {\r\n  const links: ClaimLink[] = [];\r\n\r\n  for (let i = 1; i < claims.length; i++) {\r\n    links.push({\r\n      from: claims[i - 1].id,\r\n      to: claims[i].id,\r\n    });\r\n  }\r\n\r\n  return links;\r\n}\r\n"],"names":[],"mappings":";;;AAOO,SAAS,WAAW,MAAe;IACxC,MAAM,QAAqB,EAAE;IAE7B,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;QACtC,MAAM,IAAI,CAAC;YACT,MAAM,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE;YACtB,IAAI,MAAM,CAAC,EAAE,CAAC,EAAE;QAClB;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/reasoning/graph-builder.ts"],"sourcesContent":["// core/reasoning/graph-builder.ts\r\nimport { Claim } from \"../claims/claim-decomposer\";\r\nimport { ClaimLink } from \"../claims/claim-linker\";\r\n\r\nexport interface GraphStats {\r\n  isolatedNodes: string[];\r\n  bridgeCount: number;\r\n  depth: number;\r\n}\r\n\r\nexport interface ReasoningGraph {\r\n  nodes: Claim[];\r\n  edges: ClaimLink[];\r\n  stats: GraphStats;\r\n}\r\n\r\nexport function buildGraph(\r\n  claims: Claim[],\r\n  links: ClaimLink[]\r\n): ReasoningGraph {\r\n  // Identify isolated nodes (Claims with no incoming or outgoing support)\r\n  const linkedIds = new Set([\r\n    ...links.map(l => l.from),\r\n    ...links.map(l => l.to)\r\n  ]);\r\n  \r\n  const isolatedNodes = claims\r\n    .filter(c => !linkedIds.has(c.id))\r\n    .map(c => c.id);\r\n\r\n  return {\r\n    nodes: claims,\r\n    edges: links,\r\n    stats: {\r\n      isolatedNodes,\r\n      bridgeCount: links.length,\r\n      depth: calculateGraphDepth(links, claims)\r\n    }\r\n  };\r\n}\r\n\r\nfunction calculateGraphDepth(links: ClaimLink[], claims: Claim[]): number {\r\n  if (claims.length === 0) return 0;\r\n  // Simple heuristic for production: longest sequential path\r\n  const adj = new Map<string, string[]>();\r\n  links.forEach(l => {\r\n    const neighbors = adj.get(l.from) || [];\r\n    neighbors.push(l.to);\r\n    adj.set(l.from, neighbors);\r\n  });\r\n\r\n  let maxDepth = 0;\r\n  const visited = new Set<string>();\r\n\r\n  function dfs(id: string, currentDepth: number) {\r\n    maxDepth = Math.max(maxDepth, currentDepth);\r\n    visited.add(id);\r\n    (adj.get(id) || []).forEach(next => {\r\n      if (!visited.has(next)) dfs(next, currentDepth + 1);\r\n    });\r\n    visited.delete(id);\r\n  }\r\n\r\n  claims.forEach(c => dfs(c.id, 1));\r\n  return maxDepth;\r\n}"],"names":[],"mappings":"AAAA,kCAAkC;;;;AAgB3B,SAAS,WACd,MAAe,EACf,KAAkB;IAElB,wEAAwE;IACxE,MAAM,YAAY,IAAI,IAAI;WACrB,MAAM,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI;WACrB,MAAM,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE;KACvB;IAED,MAAM,gBAAgB,OACnB,MAAM,CAAC,CAAA,IAAK,CAAC,UAAU,GAAG,CAAC,EAAE,EAAE,GAC/B,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE;IAEhB,OAAO;QACL,OAAO;QACP,OAAO;QACP,OAAO;YACL;YACA,aAAa,MAAM,MAAM;YACzB,OAAO,oBAAoB,OAAO;QACpC;IACF;AACF;AAEA,SAAS,oBAAoB,KAAkB,EAAE,MAAe;IAC9D,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO;IAChC,2DAA2D;IAC3D,MAAM,MAAM,IAAI;IAChB,MAAM,OAAO,CAAC,CAAA;QACZ,MAAM,YAAY,IAAI,GAAG,CAAC,EAAE,IAAI,KAAK,EAAE;QACvC,UAAU,IAAI,CAAC,EAAE,EAAE;QACnB,IAAI,GAAG,CAAC,EAAE,IAAI,EAAE;IAClB;IAEA,IAAI,WAAW;IACf,MAAM,UAAU,IAAI;IAEpB,SAAS,IAAI,EAAU,EAAE,YAAoB;QAC3C,WAAW,KAAK,GAAG,CAAC,UAAU;QAC9B,QAAQ,GAAG,CAAC;QACZ,CAAC,IAAI,GAAG,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,CAAA;YAC1B,IAAI,CAAC,QAAQ,GAAG,CAAC,OAAO,IAAI,MAAM,eAAe;QACnD;QACA,QAAQ,MAAM,CAAC;IACjB;IAEA,OAAO,OAAO,CAAC,CAAA,IAAK,IAAI,EAAE,EAAE,EAAE;IAC9B,OAAO;AACT"}},
    {"offset": {"line": 180, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 185, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/reasoning/contradiction-checker.ts"],"sourcesContent":["import { Claim } from \"../claims/claim-decomposer\";\r\n\r\nexport function detectContradictions(claims: Claim[]): string[] {\r\n  const contradictions: string[] = [];\r\n\r\n  const texts = claims.map(c => c.text.toLowerCase());\r\n\r\n  if (\r\n    texts.some(t => t.includes(\"will happen\")) &&\r\n    texts.some(t => t.includes(\"will not happen\"))\r\n  ) {\r\n    contradictions.push(\"Direct future-state contradiction detected\");\r\n  }\r\n\r\n  return contradictions;\r\n}\r\n"],"names":[],"mappings":";;;AAEO,SAAS,qBAAqB,MAAe;IAClD,MAAM,iBAA2B,EAAE;IAEnC,MAAM,QAAQ,OAAO,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,CAAC,WAAW;IAEhD,IACE,MAAM,IAAI,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,mBAC3B,MAAM,IAAI,CAAC,CAAA,IAAK,EAAE,QAAQ,CAAC,qBAC3B;QACA,eAAe,IAAI,CAAC;IACtB;IAEA,OAAO;AACT"}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 201, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/reasoning/inference-gap-detector.ts"],"sourcesContent":["import { ReasoningGraph } from \"./graph-builder\";\r\n\r\nexport function detectInferenceGaps(graph: ReasoningGraph): string[] {\r\n  const gaps: string[] = [];\r\n\r\n  if (graph.nodes.length > 1 && graph.edges.length === 0) {\r\n    gaps.push(\"Claims are not logically connected\");\r\n  }\r\n\r\n  return gaps;\r\n}\r\n"],"names":[],"mappings":";;;AAEO,SAAS,oBAAoB,KAAqB;IACvD,MAAM,OAAiB,EAAE;IAEzB,IAAI,MAAM,KAAK,CAAC,MAAM,GAAG,KAAK,MAAM,KAAK,CAAC,MAAM,KAAK,GAAG;QACtD,KAAK,IAAI,CAAC;IACZ;IAEA,OAAO;AACT"}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 216, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/engines/grounding/evidence-mapper.ts"],"sourcesContent":["// core/engines/grounding/evidence-mapper.ts\r\nimport { Claim } from \"@/core/claims/claim-decomposer\";\r\nimport { ClaimType } from \"../../claims/claim-types\"; \r\n\r\nexport interface EvidenceMatch {\r\n  claimId: string;\r\n  supported: boolean;\r\n  confidence: number;\r\n  sources: string[]; // <--- ADDED THIS (Critical Fix)\r\n  reasoning?: string;\r\n}\r\n\r\n// Mock implementation to satisfy the compiler until you connect real search\r\nexport function mapEvidence(claims: Claim[], sources: string[]): EvidenceMatch[] {\r\n  return claims.map((claim) => ({\r\n    claimId: claim.id,\r\n    supported: Math.random() > 0.3, // Mock logic\r\n    confidence: 0.8,\r\n    sources: sources, // <--- Now strictly assigning the sources to match the interface\r\n    reasoning: \"Matched via semantic similarity vector search.\"\r\n  }));\r\n}"],"names":[],"mappings":"AAAA,4CAA4C;;;;AAarC,SAAS,YAAY,MAAe,EAAE,OAAiB;IAC5D,OAAO,OAAO,GAAG,CAAC,CAAC,QAAU,CAAC;YAC5B,SAAS,MAAM,EAAE;YACjB,WAAW,KAAK,MAAM,KAAK;YAC3B,YAAY;YACZ,SAAS;YACT,WAAW;QACb,CAAC;AACH"}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/engines/grounding/grounding-engine.ts"],"sourcesContent":["// core/engines/grounding/grounding-engine.ts\r\nimport { EvidenceMatch } from \"./evidence-mapper\"; \r\n\r\nexport function computeGroundingScore(\r\n  matches: EvidenceMatch[]\r\n): number {\r\n  if (matches.length === 0) return 0;\r\n\r\n  const supported = matches.filter(m => m.supported).length;\r\n  // Basic algorithm: % of supported claims\r\n  return Math.round((supported / matches.length) * 100);\r\n}"],"names":[],"mappings":"AAAA,6CAA6C;;;;AAGtC,SAAS,sBACd,OAAwB;IAExB,IAAI,QAAQ,MAAM,KAAK,GAAG,OAAO;IAEjC,MAAM,YAAY,QAAQ,MAAM,CAAC,CAAA,IAAK,EAAE,SAAS,EAAE,MAAM;IACzD,yCAAyC;IACzC,OAAO,KAAK,KAAK,CAAC,AAAC,YAAY,QAAQ,MAAM,GAAI;AACnD"}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 249, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/engines/consistency/consistency-engine.ts"],"sourcesContent":["export function computeConsistencyScore(\r\n  contradictions: string[],\r\n  inferenceGaps: string[]\r\n): number {\r\n  const penalty =\r\n    contradictions.length * 30 + inferenceGaps.length * 15;\r\n\r\n  return Math.max(0, 100 - penalty);\r\n}\r\n"],"names":[],"mappings":";;;AAAO,SAAS,wBACd,cAAwB,EACxB,aAAuB;IAEvB,MAAM,UACJ,eAAe,MAAM,GAAG,KAAK,cAAc,MAAM,GAAG;IAEtD,OAAO,KAAK,GAAG,CAAC,GAAG,MAAM;AAC3B"}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/engines/risk/hallucination-detector.ts"],"sourcesContent":["import { RiskExplanation } from \"../../risk/types\";\r\nimport { Claim } from \"../../claims/claim-decomposer\";\r\n\r\ntype EvidenceMatch = {\r\n  claimId: string;\r\n  sources: string[];\r\n};\r\n\r\nexport function detectHallucinations(\r\n  claims: Claim[],\r\n  evidenceMatches: EvidenceMatch[]\r\n): RiskExplanation[] {\r\n\r\n  const evidenceByClaim = new Map(\r\n    evidenceMatches.map(e => [e.claimId, e.sources])\r\n  );\r\n\r\n  return claims\r\n    .filter(claim => {\r\n      const sources = evidenceByClaim.get(claim.id);\r\n      return !sources || sources.length === 0;\r\n    })\r\n    .map(claim => ({\r\n      id: `hallucination-${claim.id}`,\r\n      claimId: claim.id,\r\n      type: \"hallucination\",\r\n      severity: \"medium\",\r\n      reasoning: {\r\n        observation:\r\n          \"The claim makes an assertion without referencing supporting evidence.\",\r\n        missing: [\r\n          \"external benchmarks\",\r\n          \"independent validation\",\r\n          \"verifiable data sources\",\r\n        ],\r\n        implication:\r\n          \"This increases the risk that readers may treat speculative statements as factual.\",\r\n      },\r\n      remediation: {\r\n        action:\r\n          \"Explicitly state uncertainty or provide supporting external references.\",\r\n        example:\r\n          \"Internal testing suggests improvements, though no independent benchmarks are available yet.\",\r\n      },\r\n    }));\r\n}\r\n"],"names":[],"mappings":";;;AAQO,SAAS,qBACd,MAAe,EACf,eAAgC;IAGhC,MAAM,kBAAkB,IAAI,IAC1B,gBAAgB,GAAG,CAAC,CAAA,IAAK;YAAC,EAAE,OAAO;YAAE,EAAE,OAAO;SAAC;IAGjD,OAAO,OACJ,MAAM,CAAC,CAAA;QACN,MAAM,UAAU,gBAAgB,GAAG,CAAC,MAAM,EAAE;QAC5C,OAAO,CAAC,WAAW,QAAQ,MAAM,KAAK;IACxC,GACC,GAAG,CAAC,CAAA,QAAS,CAAC;YACb,IAAI,CAAC,cAAc,EAAE,MAAM,EAAE,CAAC,CAAC;YAC/B,SAAS,MAAM,EAAE;YACjB,MAAM;YACN,UAAU;YACV,WAAW;gBACT,aACE;gBACF,SAAS;oBACP;oBACA;oBACA;iBACD;gBACD,aACE;YACJ;YACA,aAAa;gBACX,QACE;gBACF,SACE;YACJ;QACF,CAAC;AACL"}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/engines/risk/overconfidence-detector.ts"],"sourcesContent":["import { Claim } from \"../../claims/claim-decomposer\";\r\nimport { Tone } from \"../../intake/tone-calibration\";\r\n\r\nexport function detectOverconfidence(\r\n  claims: Claim[],\r\n  tone: Tone\r\n): string[] {\r\n  if (tone !== \"assertive\") return [];\r\n\r\n  return claims\r\n    .filter(c => c.type === \"predictive\" || c.type === \"numerical\")\r\n    .map(c => `Overconfident phrasing in ${c.id}`);\r\n}\r\n"],"names":[],"mappings":";;;AAGO,SAAS,qBACd,MAAe,EACf,IAAU;IAEV,IAAI,SAAS,aAAa,OAAO,EAAE;IAEnC,OAAO,OACJ,MAAM,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,gBAAgB,EAAE,IAAI,KAAK,aAClD,GAAG,CAAC,CAAA,IAAK,CAAC,0BAA0B,EAAE,EAAE,EAAE,CAAC,CAAC;AACjD"}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/engines/assumptions/assumption-extractor.ts"],"sourcesContent":["import { Claim } from \"../../claims/claim-decomposer\";\r\n\r\nexport function extractAssumptions(claims: Claim[]): string[] {\r\n  const assumptions: string[] = [];\r\n\r\n  claims.forEach(c => {\r\n    if (c.text.includes(\"assumes\")) {\r\n      assumptions.push(c.text);\r\n    }\r\n  });\r\n\r\n  return assumptions;\r\n}\r\n"],"names":[],"mappings":";;;AAEO,SAAS,mBAAmB,MAAe;IAChD,MAAM,cAAwB,EAAE;IAEhC,OAAO,OAAO,CAAC,CAAA;QACb,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;YAC9B,YAAY,IAAI,CAAC,EAAE,IAAI;QACzB;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 326, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/engines/risk/semantic-validator.ts"],"sourcesContent":["// core/engines/risk/semantic-validator.ts\r\nimport { Claim } from \"../../claims/claim-decomposer\";\r\nimport { RiskExplanation } from \"../../risk/types\";\r\nimport { Domain } from \"../../intake/domain-classifier\";\r\n\r\n/**\r\n * World-Class Logic Gates:\r\n * Checks claims against fundamental Universal Constraints.\r\n */\r\nexport async function detectSemanticViolations(claims: Claim[], domain: Domain): Promise<RiskExplanation[]> {\r\n  const risks: RiskExplanation[] = [];\r\n  for (const claim of claims) {\r\n    // Physics/Science Gate: Flag entropy/perpetual motion violations\r\n    if (domain === \"research\" && /(entropy|perpetual|faster than light|over-unity)/i.test(claim.text)) {\r\n      risks.push(createRisk(claim, \"high\", \"Violation of fundamental physical laws detected.\"));\r\n    }\r\n    // Regulatory Gate: Flag SEC 'Guaranteed Returns' or FDA 'Instant Cure'\r\n    if ((domain === \"finance\" || domain === \"legal\") && /(100% guaranteed|no-risk profit|bypass regulation)/i.test(claim.text)) {\r\n      risks.push(createRisk(claim, \"high\", \"SEC/Regulatory violation: Guaranteed returns without risk disclosure are legally invalid.\"));\r\n    }\r\n  }\r\n  return risks;\r\n}\r\n\r\nfunction createRisk(claim: Claim, severity: any, observation: string): RiskExplanation {\r\n  return {\r\n    id: `semantic-${claim.id}`, claimId: claim.id, type: \"hallucination\", severity,\r\n    reasoning: { observation, implication: \"This claim forms a logical impossibility that invalidates the surrounding context.\" },\r\n    remediation: { action: \"Remove absolute qualifiers or cite breakthrough validation results.\" }\r\n  };\r\n}"],"names":[],"mappings":"AAAA,0CAA0C;;;;AASnC,eAAe,yBAAyB,MAAe,EAAE,MAAc;IAC5E,MAAM,QAA2B,EAAE;IACnC,KAAK,MAAM,SAAS,OAAQ;QAC1B,iEAAiE;QACjE,IAAI,WAAW,cAAc,oDAAoD,IAAI,CAAC,MAAM,IAAI,GAAG;YACjG,MAAM,IAAI,CAAC,WAAW,OAAO,QAAQ;QACvC;QACA,uEAAuE;QACvE,IAAI,CAAC,WAAW,aAAa,WAAW,OAAO,KAAK,sDAAsD,IAAI,CAAC,MAAM,IAAI,GAAG;YAC1H,MAAM,IAAI,CAAC,WAAW,OAAO,QAAQ;QACvC;IACF;IACA,OAAO;AACT;AAEA,SAAS,WAAW,KAAY,EAAE,QAAa,EAAE,WAAmB;IAClE,OAAO;QACL,IAAI,CAAC,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;QAAE,SAAS,MAAM,EAAE;QAAE,MAAM;QAAiB;QACtE,WAAW;YAAE;YAAa,aAAa;QAAqF;QAC5H,aAAa;YAAE,QAAQ;QAAsE;IAC/F;AACF"}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/engines/risk/refutation-engine.ts"],"sourcesContent":["// core/engines/risk/refutation-engine.ts\r\nimport { Claim } from \"../../claims/claim-decomposer\";\r\nimport { LLMProvider } from \"../../../lib/llm/provider-adapter\";\r\nimport { RiskExplanation } from \"../../risk/types\";\r\n\r\n/**\r\n * The 'Red-Team' Refutation Engine:\r\n * Actively attempts to prove a claim is FALSE.\r\n */\r\nexport async function runAdversarialRefutation(claims: Claim[], provider: LLMProvider): Promise<RiskExplanation[]> {\r\n  const risks: RiskExplanation[] = [];\r\n  await Promise.all(claims.map(async (claim) => {\r\n    const prompt = `Act as a Skeptical Auditor. DEBUNK this claim: \"${claim.text}\". \r\n    Look for hidden assumptions or data gaps. Return JSON {\"reason\": string, \"implication\": string} or \"null\".`;\r\n    \r\n    const response = await provider.generate({ prompt, temperature: 0.1 });\r\n    const text = response.text.replace(/```json|```/g, \"\").trim();\r\n    if (text !== \"null\") {\r\n      try {\r\n        const defect = JSON.parse(text);\r\n        risks.push({\r\n          id: `refute-${claim.id}`, claimId: claim.id, type: \"consistency\", severity: \"medium\",\r\n          reasoning: { observation: defect.reason, implication: defect.implication },\r\n          remediation: { action: \"Provide specific substantiation for this logical gap.\" }\r\n        });\r\n      } catch (e) {}\r\n    }\r\n  }));\r\n  return risks;\r\n}"],"names":[],"mappings":"AAAA,yCAAyC;;;;AASlC,eAAe,yBAAyB,MAAe,EAAE,QAAqB;IACnF,MAAM,QAA2B,EAAE;IACnC,MAAM,QAAQ,GAAG,CAAC,OAAO,GAAG,CAAC,OAAO;QAClC,MAAM,SAAS,CAAC,gDAAgD,EAAE,MAAM,IAAI,CAAC;8GAC6B,CAAC;QAE3G,MAAM,WAAW,MAAM,SAAS,QAAQ,CAAC;YAAE;YAAQ,aAAa;QAAI;QACpE,MAAM,OAAO,SAAS,IAAI,CAAC,OAAO,CAAC,gBAAgB,IAAI,IAAI;QAC3D,IAAI,SAAS,QAAQ;YACnB,IAAI;gBACF,MAAM,SAAS,KAAK,KAAK,CAAC;gBAC1B,MAAM,IAAI,CAAC;oBACT,IAAI,CAAC,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC;oBAAE,SAAS,MAAM,EAAE;oBAAE,MAAM;oBAAe,UAAU;oBAC5E,WAAW;wBAAE,aAAa,OAAO,MAAM;wBAAE,aAAa,OAAO,WAAW;oBAAC;oBACzE,aAAa;wBAAE,QAAQ;oBAAwD;gBACjF;YACF,EAAE,OAAO,GAAG,CAAC;QACf;IACF;IACA,OAAO;AACT"}},
    {"offset": {"line": 399, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/reasoning/causal-validator.ts"],"sourcesContent":["// core/reasoning/causal-validator.ts\r\nimport { Claim } from \"../claims/claim-decomposer\";\r\nimport { ReasoningGraph } from \"./graph-builder\";\r\nimport { RiskExplanation } from \"../risk/types\";\r\nimport { LLMProvider } from \"../../lib/llm/provider-adapter\";\r\n\r\nexport async function validateCausalBridgesProduction(\r\n  graph: ReasoningGraph, \r\n  claims: Claim[], \r\n  provider: LLMProvider\r\n): Promise<RiskExplanation[]> {\r\n  const risks: RiskExplanation[] = [];\r\n  await Promise.all(graph.edges.map(async (edge) => {\r\n    const source = claims.find(c => c.id === edge.from);\r\n    const target = claims.find(c => c.id === edge.to);\r\n    if (!source || !target) return;\r\n\r\n    const prompt = `MECE Logic Audit: \r\n    Premise A: \"${source.text}\" \r\n    Conclusion B: \"${target.text}\" \r\n    Is this causal link logically sufficient? Search for 'Leaps of Faith' or 'Non Sequiturs'. \r\n    Return JSON {\"defect\": string, \"severity\": \"high\"|\"medium\"} or \"null\".`;\r\n    \r\n    const response = await provider.generate({ prompt, temperature: 0 });\r\n    const text = response.text.replace(/```json|```/g, \"\").trim();\r\n    if (text !== \"null\") {\r\n      try {\r\n        const audit = JSON.parse(text);\r\n        risks.push({\r\n          id: `bridge-${source.id}-${target.id}`, claimId: target.id, type: \"consistency\", severity: audit.severity,\r\n          reasoning: { observation: audit.defect, implication: \"Strategic logical gap: the conclusion assumes a 100% conversion that is not evidenced.\" },\r\n          remediation: { action: \"Define the specific variables that bridge these two assertions.\" }\r\n        });\r\n      } catch (e) {}\r\n    }\r\n  }));\r\n  return risks;\r\n}"],"names":[],"mappings":"AAAA,qCAAqC;;;;AAM9B,eAAe,gCACpB,KAAqB,EACrB,MAAe,EACf,QAAqB;IAErB,MAAM,QAA2B,EAAE;IACnC,MAAM,QAAQ,GAAG,CAAC,MAAM,KAAK,CAAC,GAAG,CAAC,OAAO;QACvC,MAAM,SAAS,OAAO,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,IAAI;QAClD,MAAM,SAAS,OAAO,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KAAK,EAAE;QAChD,IAAI,CAAC,UAAU,CAAC,QAAQ;QAExB,MAAM,SAAS,CAAC;gBACJ,EAAE,OAAO,IAAI,CAAC;mBACX,EAAE,OAAO,IAAI,CAAC;;0EAEyC,CAAC;QAEvE,MAAM,WAAW,MAAM,SAAS,QAAQ,CAAC;YAAE;YAAQ,aAAa;QAAE;QAClE,MAAM,OAAO,SAAS,IAAI,CAAC,OAAO,CAAC,gBAAgB,IAAI,IAAI;QAC3D,IAAI,SAAS,QAAQ;YACnB,IAAI;gBACF,MAAM,QAAQ,KAAK,KAAK,CAAC;gBACzB,MAAM,IAAI,CAAC;oBACT,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC;oBAAE,SAAS,OAAO,EAAE;oBAAE,MAAM;oBAAe,UAAU,MAAM,QAAQ;oBACzG,WAAW;wBAAE,aAAa,MAAM,MAAM;wBAAE,aAAa;oBAAyF;oBAC9I,aAAa;wBAAE,QAAQ;oBAAkE;gBAC3F;YACF,EAAE,OAAO,GAAG,CAAC;QACf;IACF;IACA,OAAO;AACT"}},
    {"offset": {"line": 445, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 450, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/scoring/trust-score.ts"],"sourcesContent":["export interface ETSComponents {\r\n  grounding: number;\r\n  consistency: number;\r\n  assumptions: number;\r\n  safety: number;\r\n  security: number;\r\n  calibration: number;\r\n}\r\n\r\nexport function computeETS(\r\n  components: ETSComponents,\r\n  weights: Record<keyof ETSComponents, number>\r\n): number {\r\n  let total = 0;\r\n\r\n  for (const key in components) {\r\n    total += components[key as keyof ETSComponents] *\r\n      weights[key as keyof ETSComponents];\r\n  }\r\n\r\n  return Math.round(total);\r\n}\r\n"],"names":[],"mappings":";;;AASO,SAAS,WACd,UAAyB,EACzB,OAA4C;IAE5C,IAAI,QAAQ;IAEZ,IAAK,MAAM,OAAO,WAAY;QAC5B,SAAS,UAAU,CAAC,IAA2B,GAC7C,OAAO,CAAC,IAA2B;IACvC;IAEA,OAAO,KAAK,KAAK,CAAC;AACpB"}},
    {"offset": {"line": 460, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 465, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/scoring/weighting-profiles.ts"],"sourcesContent":["export const ETS_WEIGHTS = {\r\n  founder: {\r\n    grounding: 0.25,\r\n    consistency: 0.25,\r\n    assumptions: 0.1,\r\n    safety: 0.15,\r\n    security: 0.1,\r\n    calibration: 0.15,\r\n  },\r\n  legal: {\r\n    grounding: 0.3,\r\n    consistency: 0.3,\r\n    assumptions: 0.15,\r\n    safety: 0.15,\r\n    security: 0.05,\r\n    calibration: 0.05,\r\n  },\r\n} as const;\r\n\r\n/* ðŸ‘‡ THIS IS THE KEY LINE */\r\nexport type WeightProfile = keyof typeof ETS_WEIGHTS;\r\n"],"names":[],"mappings":";;;AAAO,MAAM,cAAc;IACzB,SAAS;QACP,WAAW;QACX,aAAa;QACb,aAAa;QACb,QAAQ;QACR,UAAU;QACV,aAAa;IACf;IACA,OAAO;QACL,WAAW;QACX,aAAa;QACb,aAAa;QACb,QAAQ;QACR,UAAU;QACV,aAAa;IACf;AACF"}},
    {"offset": {"line": 486, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 491, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/core/pipelines/verify-pipeline.ts"],"sourcesContent":["// core/pipelines/verify-pipeline.ts\r\n\r\nimport { normalizeInput } from \"../intake/normalize\";\r\nimport { calibrateTone } from \"../intake/tone-calibration\";\r\nimport { classifyDomain, Domain } from \"../intake/domain-classifier\";\r\n\r\nimport { decomposeClaimsAdvanced, Claim } from \"../claims/claim-decomposer\";\r\nimport { performWebSearch } from \"../../lib/tools/google-search\";\r\nimport { linkClaims } from \"../claims/claim-linker\";\r\nimport { buildGraph } from \"../reasoning/graph-builder\";\r\n\r\nimport { detectContradictions } from \"../reasoning/contradiction-checker\";\r\nimport { detectInferenceGaps } from \"../reasoning/inference-gap-detector\";\r\n\r\nimport { mapEvidence } from \"../engines/grounding/evidence-mapper\";\r\nimport { computeGroundingScore } from \"../engines/grounding/grounding-engine\";\r\nimport { computeConsistencyScore } from \"../engines/consistency/consistency-engine\";\r\n\r\nimport { detectHallucinations } from \"../engines/risk/hallucination-detector\";\r\nimport { detectOverconfidence } from \"../engines/risk/overconfidence-detector\";\r\nimport { extractAssumptions } from \"../engines/assumptions/assumption-extractor\";\r\n\r\nimport { detectSemanticViolations } from \"../engines/risk/semantic-validator\";\r\nimport { runAdversarialRefutation } from \"../engines/risk/refutation-engine\";\r\nimport { validateCausalBridgesProduction } from \"../reasoning/causal-validator\";\r\n\r\nimport { computeETS, ETSComponents } from \"../scoring/trust-score\";\r\nimport { ETS_WEIGHTS, WeightProfile } from \"../scoring/weighting-profiles\";\r\nimport { RiskExplanation } from \"../risk/types\";\r\nimport { LLMProvider } from \"../../lib/llm/provider-adapter\";\r\n\r\n/**\r\n * World-Class Audit Result Structure\r\n */\r\nexport interface VerifyResult {\r\n  score: number;\r\n  claims: Claim[];\r\n  risks: RiskExplanation[];\r\n  explainability: {\r\n    contradictions: string[];\r\n    inferenceGaps: string[];\r\n    overconfidence: string[];\r\n    assumptions: string[];\r\n    auditStatus: \"PASSED\" | \"CRITICAL_FAILURE\";\r\n  };\r\n}\r\n\r\nconst DEFAULT_PROFILE: WeightProfile = \"founder\";\r\n\r\n/**\r\n * The Adversarial Verification Pipeline:\r\n * Performs structural, semantic, and causal auditing against live reality anchors.\r\n */\r\nexport async function verifyPipeline(\r\n  rawText: string,\r\n  profile: WeightProfile = DEFAULT_PROFILE,\r\n  provider: LLMProvider, // Required for World-Class Semantic Auditing\r\n  sources: string[] = []\r\n): Promise<VerifyResult> {\r\n  // 1. Intake & Forensic Signal Processing\r\n  const text = normalizeInput(rawText);\r\n  const tone = calibrateTone(text);\r\n  const domain: Domain = classifyDomain(text);\r\n\r\n  // 2. Forensic Claim Decomposition (Adversarial LLM-driven)\r\n  // Replaces heuristic extraction with Audit Gravity assessment\r\n  const claims = await decomposeClaimsAdvanced(text, provider);\r\n\r\n  // 3. Structural Reasoning & Live Grounding (Parallel)\r\n  const [links, liveEvidence] = await Promise.all([\r\n    Promise.resolve(linkClaims(claims)),\r\n    Promise.all(\r\n      claims\r\n        .filter((c) => c.gravity === \"critical\" || c.gravity === \"high\")\r\n        .slice(0, 3) // Real-world grounding for high-stakes claims\r\n        .map(async (claim) => {\r\n          const results = await performWebSearch(claim.text);\r\n          return { claimId: claim.id, results };\r\n        })\r\n    ),\r\n  ]);\r\n\r\n  const graph = buildGraph(claims, links);\r\n  const liveLinks = liveEvidence.flatMap((le) => le.results.map((r) => r.link));\r\n  const allSources = [...sources, ...liveLinks];\r\n\r\n  // 4. Multi-Stage Adversarial Auditing (Parallel)\r\n  // Simultaneous check for: Semantic Laws, Red-Team Refutations, and Causal Sufficiency\r\n  const [semanticRisks, refutationRisks, causalRisks] = await Promise.all([\r\n    detectSemanticViolations(claims, domain),\r\n    runAdversarialRefutation(claims, provider),\r\n    validateCausalBridgesProduction(graph, claims, provider),\r\n  ]);\r\n\r\n  // 5. Heuristic Defect Processing\r\n  const contradictions = detectContradictions(claims);\r\n  const inferenceGaps = detectInferenceGaps(graph);\r\n  const evidenceMatches = mapEvidence(claims, allSources);\r\n  const hallucinationRisks = detectHallucinations(claims, evidenceMatches);\r\n  const overconfidenceSignals = detectOverconfidence(claims, tone);\r\n  const assumptions = extractAssumptions(claims);\r\n\r\n  // 6. Global Risk Aggregation\r\n  const allRisks = [\r\n    ...semanticRisks,\r\n    ...refutationRisks,\r\n    ...causalRisks,\r\n    ...hallucinationRisks,\r\n  ];\r\n\r\n  // 7. Whitepaper-Aligned Scoring Logic\r\n  const groundingScore = computeGroundingScore(evidenceMatches);\r\n  const consistencyScore = computeConsistencyScore(contradictions, inferenceGaps);\r\n\r\n  const components: ETSComponents = {\r\n    grounding: groundingScore,\r\n    consistency: consistencyScore,\r\n    assumptions: Math.max(0, 100 - assumptions.length * 10),\r\n    safety: Math.max(0, 100 - allRisks.filter((r) => r.severity === \"high\").length * 25),\r\n    security: 100, // Security layer placeholder\r\n    calibration: Math.max(0, 100 - overconfidenceSignals.length * 10),\r\n  };\r\n\r\n  let score = Math.max(0, Math.round(computeETS(components, ETS_WEIGHTS[profile])));\r\n\r\n  // 8. LOGIC GATE: High-Gravity Override\r\n  // If a claim violates physical/legal laws or red-team debunking found high severity issues, \r\n  // cap the score at 18/100 regardless of citations.\r\n  const hasCriticalFailure =\r\n    allRisks.some((r) => r.severity === \"high\") ||\r\n    claims.some((c) => c.gravity === \"critical\");\r\n\r\n  if (hasCriticalFailure) {\r\n    score = Math.min(score, 18);\r\n  }\r\n\r\n  // 9. Enterprise Audit Return Package\r\n  return {\r\n    score,\r\n    claims,\r\n    risks: allRisks,\r\n    explainability: {\r\n      contradictions,\r\n      inferenceGaps,\r\n      overconfidence: overconfidenceSignals,\r\n      assumptions,\r\n      auditStatus: hasCriticalFailure ? \"CRITICAL_FAILURE\" : \"PASSED\",\r\n    },\r\n  };\r\n}"],"names":[],"mappings":"AAAA,oCAAoC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CpC,MAAM,kBAAiC;AAMhC,eAAe,eACpB,OAAe,EACf,UAAyB,eAAe,EACxC,QAAqB,EACrB,UAAoB,EAAE;IAEtB,yCAAyC;IACzC,MAAM,OAAO,8IAAe;IAC5B,MAAM,OAAO,uJAAc;IAC3B,MAAM,SAAiB,yJAAe;IAEtC,2DAA2D;IAC3D,8DAA8D;IAC9D,MAAM,SAAS,MAAM,iKAAwB,MAAM;IAEnD,sDAAsD;IACtD,MAAM,CAAC,OAAO,aAAa,GAAG,MAAM,QAAQ,GAAG,CAAC;QAC9C,QAAQ,OAAO,CAAC,gJAAW;QAC3B,QAAQ,GAAG,CACT,OACG,MAAM,CAAC,CAAC,IAAM,EAAE,OAAO,KAAK,cAAc,EAAE,OAAO,KAAK,QACxD,KAAK,CAAC,GAAG,GAAG,8CAA8C;SAC1D,GAAG,CAAC,OAAO;YACV,MAAM,UAAU,MAAM,qJAAiB,MAAM,IAAI;YACjD,OAAO;gBAAE,SAAS,MAAM,EAAE;gBAAE;YAAQ;QACtC;KAEL;IAED,MAAM,QAAQ,oJAAW,QAAQ;IACjC,MAAM,YAAY,aAAa,OAAO,CAAC,CAAC,KAAO,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI;IAC3E,MAAM,aAAa;WAAI;WAAY;KAAU;IAE7C,iDAAiD;IACjD,sFAAsF;IACtF,MAAM,CAAC,eAAe,iBAAiB,YAAY,GAAG,MAAM,QAAQ,GAAG,CAAC;QACtE,6KAAyB,QAAQ;QACjC,4KAAyB,QAAQ;QACjC,4KAAgC,OAAO,QAAQ;KAChD;IAED,iCAAiC;IACjC,MAAM,iBAAiB,sKAAqB;IAC5C,MAAM,gBAAgB,yKAAoB;IAC1C,MAAM,kBAAkB,kKAAY,QAAQ;IAC5C,MAAM,qBAAqB,6KAAqB,QAAQ;IACxD,MAAM,wBAAwB,8KAAqB,QAAQ;IAC3D,MAAM,cAAc,gLAAmB;IAEvC,6BAA6B;IAC7B,MAAM,WAAW;WACZ;WACA;WACA;WACA;KACJ;IAED,sCAAsC;IACtC,MAAM,iBAAiB,6KAAsB;IAC7C,MAAM,mBAAmB,mLAAwB,gBAAgB;IAEjE,MAAM,aAA4B;QAChC,WAAW;QACX,aAAa;QACb,aAAa,KAAK,GAAG,CAAC,GAAG,MAAM,YAAY,MAAM,GAAG;QACpD,QAAQ,KAAK,GAAG,CAAC,GAAG,MAAM,SAAS,MAAM,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK,QAAQ,MAAM,GAAG;QACjF,UAAU;QACV,aAAa,KAAK,GAAG,CAAC,GAAG,MAAM,sBAAsB,MAAM,GAAG;IAChE;IAEA,IAAI,QAAQ,KAAK,GAAG,CAAC,GAAG,KAAK,KAAK,CAAC,gJAAW,YAAY,uJAAW,CAAC,QAAQ;IAE9E,uCAAuC;IACvC,6FAA6F;IAC7F,mDAAmD;IACnD,MAAM,qBACJ,SAAS,IAAI,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK,WACpC,OAAO,IAAI,CAAC,CAAC,IAAM,EAAE,OAAO,KAAK;IAEnC,IAAI,oBAAoB;QACtB,QAAQ,KAAK,GAAG,CAAC,OAAO;IAC1B;IAEA,qCAAqC;IACrC,OAAO;QACL;QACA;QACA,OAAO;QACP,gBAAgB;YACd;YACA;YACA,gBAAgB;YAChB;YACA,aAAa,qBAAqB,qBAAqB;QACzD;IACF;AACF"}},
    {"offset": {"line": 617, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 622, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/llm/openai.ts"],"sourcesContent":["import { LLMProvider, LLMRequest, LLMResponse } from \"./provider-adapter\";\r\n\r\nexport class OpenAIProvider implements LLMProvider {\r\n  name = \"openai\";\r\n\r\n  constructor(private apiKey: string) {}\r\n\r\n  async generate(req: LLMRequest): Promise<LLMResponse> {\r\n    const res = await fetch(\"https://api.openai.com/v1/chat/completions\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        Authorization: `Bearer ${this.apiKey}`,\r\n        \"Content-Type\": \"application/json\",\r\n      },\r\n      body: JSON.stringify({\r\n        model: \"gpt-4.1-mini\",\r\n        messages: [{ role: \"user\", content: req.prompt }],\r\n        temperature: req.temperature ?? 0,\r\n      }),\r\n    });\r\n\r\n    const json = await res.json();\r\n\r\n    return {\r\n      text: json.choices[0].message.content,\r\n      model: json.model,\r\n      provider: this.name,\r\n    };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;AAEO,MAAM;;IACX,KAAgB;IAEhB,YAAY,AAAQ,MAAc,CAAE;aAAhB,SAAA;aAFpB,OAAO;IAE8B;IAErC,MAAM,SAAS,GAAe,EAAwB;QACpD,MAAM,MAAM,MAAM,MAAM,8CAA8C;YACpE,QAAQ;YACR,SAAS;gBACP,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;gBACtC,gBAAgB;YAClB;YACA,MAAM,KAAK,SAAS,CAAC;gBACnB,OAAO;gBACP,UAAU;oBAAC;wBAAE,MAAM;wBAAQ,SAAS,IAAI,MAAM;oBAAC;iBAAE;gBACjD,aAAa,IAAI,WAAW,IAAI;YAClC;QACF;QAEA,MAAM,OAAO,MAAM,IAAI,IAAI;QAE3B,OAAO;YACL,MAAM,KAAK,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO;YACrC,OAAO,KAAK,KAAK;YACjB,UAAU,IAAI,CAAC,IAAI;QACrB;IACF;AACF"}},
    {"offset": {"line": 658, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 663, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/logging/logger.ts"],"sourcesContent":["export type LogLevel = \"info\" | \"warn\" | \"error\";\r\n\r\nexport function log(level: LogLevel, message: string, meta?: unknown) {\r\n  const entry = {\r\n    level,\r\n    message,\r\n    meta,\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n\r\n  console[level](JSON.stringify(entry));\r\n}\r\n"],"names":[],"mappings":";;;AAEO,SAAS,IAAI,KAAe,EAAE,OAAe,EAAE,IAAc;IAClE,MAAM,QAAQ;QACZ;QACA;QACA;QACA,WAAW,IAAI,OAAO,WAAW;IACnC;IAEA,OAAO,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC;AAChC"}},
    {"offset": {"line": 675, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 680, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/app/api/verify/route.ts"],"sourcesContent":["// app/api/verify/route.ts\r\nimport { NextRequest, NextResponse } from \"next/server\";\r\nimport { verifyPipeline } from \"@/core/pipelines/verify-pipeline\";\r\nimport { OpenAIProvider } from \"@/lib/llm/openai\";\r\nimport { log } from \"@/lib/logging/logger\";\r\n\r\nexport async function POST(req: NextRequest) {\r\n  try {\r\n    const body = await req.json();\r\n    const { content, profile, sources = [], userId } = body;\r\n\r\n    if (!content || !profile) {\r\n      return NextResponse.json({ error: \"Missing content or profile\" }, { status: 400 });\r\n    }\r\n\r\n    // Initialize the World's Best Auditor Engine\r\n    const provider = new OpenAIProvider(process.env.OPENAI_API_KEY || \"\");\r\n\r\n    // Must be awaited because the advanced pipeline is async\r\n    const result = await verifyPipeline(\r\n      content,\r\n      profile,\r\n      provider,\r\n      sources\r\n    );\r\n\r\n    log(\"info\", \"Advanced Verification completed\", { userId, score: result.score });\r\n\r\n    return NextResponse.json({ ok: true, result });\r\n  } catch (err: any) {\r\n    log(\"error\", \"Verification failed\", err);\r\n    return NextResponse.json({ error: \"Internal verification error\" }, { status: 500 });\r\n  }\r\n}"],"names":[],"mappings":"AAAA,0BAA0B;;;;;;;;;;;;;AAMnB,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,EAAE,MAAM,EAAE,GAAG;QAEnD,IAAI,CAAC,WAAW,CAAC,SAAS;YACxB,OAAO,wLAAa,IAAI,CAAC;gBAAE,OAAO;YAA6B,GAAG;gBAAE,QAAQ;YAAI;QAClF;QAEA,6CAA6C;QAC7C,MAAM,WAAW,2IAAmB,QAAQ,GAAG,CAAC,cAAc,IAAI;QAElE,yDAAyD;QACzD,MAAM,SAAS,MAAM,0JACnB,SACA,SACA,UACA;QAGF,gIAAI,QAAQ,mCAAmC;YAAE;YAAQ,OAAO,OAAO,KAAK;QAAC;QAE7E,OAAO,wLAAa,IAAI,CAAC;YAAE,IAAI;YAAM;QAAO;IAC9C,EAAE,OAAO,KAAU;QACjB,gIAAI,SAAS,uBAAuB;QACpC,OAAO,wLAAa,IAAI,CAAC;YAAE,OAAO;QAA8B,GAAG;YAAE,QAAQ;QAAI;IACnF;AACF"}},
    {"offset": {"line": 725, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 729, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/.next-internal/server/app/api/verify/route/actions.js"],"sourcesContent":["__turbopack_export_value__({\n});"],"names":[],"mappings":"AAAA,2BAA2B,CAC3B"}},
    {"offset": {"line": 730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}